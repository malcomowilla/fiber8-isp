import Accordion from '@mui/material/Accordion';
import AccordionSummary from '@mui/material/AccordionSummary';
import AccordionDetails from '@mui/material/AccordionDetails';
import Typography from '@mui/material/Typography';
import ArrowDownwardIcon from '@mui/icons-material/ArrowDownward';
import ArrowDropDownIcon from '@mui/icons-material/ArrowDropDown';
import FormGroup from '@mui/material/FormGroup';
import FormControlLabel from '@mui/material/FormControlLabel';
import Checkbox from '@mui/material/Checkbox';
import Box from '@mui/material/Box';
import TextField from '@mui/material/TextField';
import Tooltip from '@mui/material/Tooltip';
import Backdrop from '../backdrop/Backdrop'
import Alert from '@mui/material/Alert';
import Stack from '@mui/material/Stack';
import AlertTitle from '@mui/material/AlertTitle';
import Autocomplete from '@mui/material/Autocomplete';
import { useDebounce } from 'use-debounce';
import styled from "styled-components";
import { motion } from "framer-motion";
import CheckCircleIcon from "@mui/icons-material/CheckCircle";
import { FaRegBuilding } from "react-icons/fa";
import { FaQuestion } from "react-icons/fa6";
import { MdOutlineMailOutline } from "react-icons/md";
import { MdOutlinePhonelinkSetup } from "react-icons/md";





// import { Button } from "@/components/ui/button"

// import LoadingButton from '@mui/lab/LoadingButton';
import AutorenewIcon from '@mui/icons-material/Autorenew';
// import CloseIcon from '@mui/icons-material/Close';

import {useState, useEffect,  useCallback, useMemo,
  createContext, useContext,Suspense, lazy
} from 'react'
import { useApplicationSettings } from './ApplicationSettings';
import { makeStyles } from '@material-ui/core/styles';
const SettingsNotification = lazy(() => import('../notification/SettingsNotification'))

import toast, { Toaster } from 'react-hot-toast';
import UiLoader from '../uiloader/UiLoader'
import { FiUsers } from "react-icons/fi";
import { BsRouter } from "react-icons/bs";
import { CiUser } from "react-icons/ci";

import { FaPhone } from "react-icons/fa";
import { MdTextsms } from "react-icons/md";
import { IoWarningOutline } from "react-icons/io5";




const useStyles = makeStyles(theme => ({
  customTooltip: {
    backgroundColor: 'gray',
  },
  customArrow: {
    color: 'rgba(220, 0, 78, 0.8)',
  },
}));



const GeneralContext = createContext(null)


const GeneralSettings = ({children}) => {
  const { handleChange, settingsformData, isloading, setisloading,
     setFormData, companySettings, setCompanySettings,
     handleChangeSubscriberSettings,subscriberSettings,setSubscriberSettings,
     handleChangeAdminSettings, adminSettings, setAdminSettings,
    } = useApplicationSettings();


     const {contact_info, company_name, email_info, logo_url,
      agent_email,customer_support_email,customer_support_phone_number,
      
     } =
     companySettings;


     let { enable_2fa_for_admin_email, enable_2fa_for_admin_sms, send_password_via_sms,
      send_password_via_email, check_is_inactive,
      checkinactiveminutes, checkinactivehrs,checkinactivedays,
      enable_2fa_google_auth,
      enable_2fa_for_admin_passkeys
     }= adminSettings;

     const {prefix, minimum_digits, use_autogenerated_number_as_ppoe_username, notify_user_account_created,
      send_reminder_sms_expiring_subscriptions, account_number_starting_value,
      use_autogenerated_number_as_ppoe_password
     }= subscriberSettings;


  const [routerName] = useDebounce( settingsformData.router_name, 1000)

const [checkedData,  setCheckedData] = useState('')
const [open, setOpen] = useState(false);
const [openNotifactionSettings, setOpenSettings] = useState(false)
const [routers, setRouters]= useState ([])
const [smsProviders, setSmsProviders] = useState([])
const [mikrotik_router, setRouter] = useState(null)
const [sms_provider, setSmsProvider] = useState({
  sms_provider: ''
})

const classes = useStyles();



const handleChangeSmsProvider = (e) => {
  const {checked, value, name} = e.target;
  setSmsProvider({...sms_provider, [name]: value})
}


// useEffect(() => {
//   if (settingsformData.router_name) {
//     setRouter(routers.find(router => router.name === settingsformData.router_name));
//   }
// }, [settingsformData.router_name, routers]);



const subdomain = window.location.hostname.split('.')[0]
console.log('subdomain',subdomain)

const handleGetCompanySettings = useCallback(
  async() => {
    try {
      const response = await fetch('/api/get_company_settings', {
        headers: {
          'X-Subdomain': subdomain,
        },
      })
      const newData = await response.json()
      if (response.ok) {
        // setcompanySettings(newData)
        const { contact_info, company_name, email_info, logo_url,
          customer_support_phone_number,agent_email ,customer_support_email
         } = newData
         console.log(logo_url)

        setCompanySettings((prevData)=> ({...prevData, 
          contact_info, company_name, email_info,
          customer_support_phone_number,agent_email ,customer_support_email,
        
          logo_preview: logo_url
        }))

        console.log('company settings fetched', newData)
      }else{

        if (response.status === 402) {
        setTimeout(() => {
          // navigate('/license-expired')
          window.location.href='/license-expired'
         }, 1800);
        
      }
if (response.status === 401) {
  toast.error(newData.error, {
    position: "top-center",
    duration: 4000,
  })
   setTimeout(() => {
          // navigate('/license-expired')
          window.location.href='/signin'
         }, 1900);
}
        console.log('failed to fetch company settings')
      }
    } catch (error) {
      toast.error('internal server error  while fetching company settings', )
    
    }
  },
  [setCompanySettings],
)

useEffect(() => {
  
  handleGetCompanySettings()
  
}, [handleGetCompanySettings])




const fetchRouters = useMemo(() => async ()=> {
  
  try {
    const response = await fetch('/api/routers',{
      headers: {
        'X-Subdomain': subdomain,
      },
  
    }
  
  
  )
  
    const newData = await response.json()
  if (response.ok) {
    console.log('router',newData)
    setRouters(newData)

  } else {
    if (response.status === 402) {
        setTimeout(() => {
          // navigate('/license-expired')
          window.location.href='/license-expired'
         }, 1800);
        
      }
if (response.status === 401) {
  toast.error(newData.error, {
    position: "top-center",
    duration: 4000,
  })
   setTimeout(() => {
          // navigate('/license-expired')
          window.location.href='/signin'
         }, 1900);
}
    console.log('failed to fetch routers')

  }
  
  } catch (error) {
    
    console.log(error)
  
  }
  
  
  }, [])
  



  useEffect(() => {
    
    fetchRouters()
  }, [ fetchRouters, routerName]);







useEffect(() => {
  setRouter(settingsformData.router_name)

  console.log('package_name', )
}, [ settingsformData.router_name ]);


useEffect(() => {
  const fetchRouters =  async() => {


    try {
      const response = await fetch('/api/router_settings', {
        headers: {
          'X-Subdomain': subdomain,
        },
      })
const newData = await response.json()

      if (response) {
        console.log('fetched router settings', newData)
        const {router_name, use_radius} = newData[0]
        setFormData({...settingsformData, router_name, use_radius })
        setRouter(router_name)


      } else {
        if (response.status === 402) {
        setTimeout(() => {
          // navigate('/license-expired')
          window.location.href='/license-expired'
         }, 1800);
        
      }
if (response.status === 401) {
  toast.error(newData.error, {
    position: "top-center",
    duration: 4000,
  })
   setTimeout(() => {
          // navigate('/license-expired')
          window.location.href='/signin'
         }, 1900);
}
        toast.error(newData.error, {
          position: "top-center",
          duration: 4000,
        })
        toast.error('failed to fetch router settings', {
          duration: 4000,
          position: "top-center",
        });
      }
    } catch (error) {
      toast.error('failed to fetch router settings', {
        duration: 4000,
        position: "top-center",
      });
      
    }
  }
  fetchRouters()
}, []);

       const handleUpdateSettings = async(e)=> {
        e.preventDefault()

        try {
          setisloading(true)
          setOpen(true)
          const url =  '/api/router_settings' 
         const method =   'POST' 

         const response = await fetch(url, {
          method,
          headers: {
            "Content-Type"  : 'application/json',
            'X-Subdomain': subdomain,
          },

          body: JSON.stringify(
            settingsformData
          )
         },
        
        
        )


        const newData1 = await response.json()

        if (response.ok) {
          // const {prefix, minimum_digits, check_update_username, check_update_password } = newData[0]

          
const prefix = newData1.prefix
const minimum_digits = newData1.minimum_digits
const check_update_username = newData1.check_update_username
const check_update_password  = newData1.check_update_password 
const welcome_back_message = newData1.welcome_back_message
const router_name = newData1.router_name
// setCheckedData(newData1)
          localStorage.setItem("checkedtrueData2", JSON.stringify({check_update_username,  check_update_password,
            welcome_back_message, router_name
          }))
          setFormData({...settingsformData, prefix,  minimum_digits, router_name, check_update_username,
             check_update_password,
             welcome_back_message
           })
toast.success('settings updated successfully', {
  position: "top-center",
  duration: 7000,
  
})
          setisloading(false)
          setOpen(false)
          setOpenSettings(true)
          setRouter(routers.find(router => router.name === settingsformData.router_name));

        } else {
          setOpen(false)
          toast.error('failed to update settings', {
            position: "top-center",
            duration: 4000,
            
          })
          console.log('not created')
          setOpen(false)
          setisloading(false)
          setOpenSettings(false)
        }
        } catch (error) {
          toast.error(
            'Failed to update settings something went wrong',
            {
              position: "top-center",
              duration: 4000,
              
            }
          )
          console.log(error)
          setisloading(false)
          setOpenSettings(false)
        }
       }

       const handleClose = () => {
         setOpen(false);
       };
   
       
       const handleCloseNotifaction = () => {
        setOpenSettings(false);
      };

    


const handleFormDataChangeForCompany = (e) => {
  setCompanySettings((prevData)=> ({...prevData, [e.target.name]: e.target.value}))
}






const handleImageChange = (e) => {
  const file = e.target.files[0];
  if (file) {
    setCompanySettings(prevData => ({
      ...prevData,
      logo: file,
      logo_preview: URL.createObjectURL(file)
    }));
  }
};





const handleCreateCompanySettings = async (e) => {
  e.preventDefault()
try {
  setisloading(true)
  const formData = new FormData();
  formData.append('company_name', companySettings.company_name);
  formData.append('contact_info', companySettings.contact_info);
  formData.append('email_info', companySettings.email_info);
  formData.append('agent_email', companySettings.agent_email);
  formData.append('customer_support_phone_number', companySettings.customer_support_phone_number);
  formData.append('customer_support_email', companySettings.customer_support_email);




  if (companySettings.logo) {
    formData.append('logo', companySettings.logo);
  }
  const response = await fetch('/api/company_settings', {
    method: 'POST',
    headers: {
      'X-Subdomain': subdomain,
    },
   
    body: formData
  })


  const newData = await response.json()
  if (response.ok) {
    console.log('company settings created', newData)
    const { contact_info, company_name, email_info, logo_url,
      agent_email,customer_support_email,customer_support_phone_number  ,
      
     } =
     newData;


    setisloading(false)

toast.success("company settings updated successfully", {
  position: "top-center",
  duration: 7000,
})
    setCompanySettings(prevData => ({
      ...prevData, 
      contact_info, 
      company_name, 
      customer_support_phone_number,
      customer_support_email,
      agent_email,
      email_info,
      logo_preview: logo_url
    }));
  } else {
    toast.error('failed to create company settings', {
      position: "top-center",
      duration: 7000,
    })
    setisloading({...isloading, loading8: false})


    console.log('failed to create company settings')
  }

} catch (error) {
  console.log('error creating company settings',error)
  toast.error('internal server error', {
      position: "top-center",
      duration: 4000,
    })

  
  setisloading(false)
}

}









const getAdminSettings = useCallback(
  async() => {
    
    try {
      const response = await fetch('/api/admin_settings', {
        headers: {
          'X-Subdomain': subdomain,
        },
      })
      const newData = await response.json()
      if (response.ok) {
        console.log('admin settings fetched', newData)
        const {enable_2fa_for_admin_email, enable_2fa_for_admin_sms, send_password_via_sms,
          send_password_via_email, check_is_inactive,
          enable_2fa_for_admin_passkeys,
          checkinactiveminutes, checkinactivehrs,checkinactivedays, 
          enable_2fa_google_auth} = newData[0]
        setAdminSettings(prevData => ({
          ...prevData, 
          enable_2fa_for_admin_email, enable_2fa_for_admin_sms, send_password_via_sms,
          enable_2fa_for_admin_passkeys,
          send_password_via_email, check_is_inactive,
          enable_2fa_google_auth,
          checkinactiveminutes, checkinactivehrs,checkinactivedays
        }));
        console.log('admin settings fetched', newData)
      }else{



if (response.status === 402) {
        setTimeout(() => {
          // navigate('/license-expired')
          window.location.href='/license-expired'
         }, 1800);
        
      }
if (response.status === 401) {
  toast.error(newData.error, {
    position: "top-center",
    duration: 4000,
  })
   setTimeout(() => {
          // navigate('/license-expired')
          window.location.href='/signin'
         }, 1900);
}


toast.error(newData.error, {
position: "top-center",
duration: 5000,
})

        toast.error('failed to fetch admin settings', {
          position: "top-center",
          duration: 4000,
        })
      }
    } catch (error) {
      toast.error(`failed to fetch admin settings server error${error}`, {
        position: "top-center",
        duration: 4000,
      })
    }
  },
  [setAdminSettings, subdomain],
)



useEffect(() => {
  getAdminSettings()
  
}, [getAdminSettings]);
console.log('enable_2fa_google_auth=>', enable_2fa_for_admin_sms, 
'enable_2fa_for_admin_email =>',enable_2fa_for_admin_email, "enable_2fa_for_admin_passkeys =>", enable_2fa_for_admin_passkeys
)

const handleChangeAdminSetting = async(e) => {
  e.preventDefault()
  try {
    const url = subdomain === 'demo' && enable_2fa_google_auth === true || enable_2fa_for_admin_passkeys === true
    && enable_2fa_for_admin_email=== true && enable_2fa_for_admin_sms === true ?  '/api/admin_settings_demo' : '/api/admin_settings'
        
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Subdomain': subdomain,
        
        
      },
      body: JSON.stringify({
       admin_setting: adminSettings
      })
    })

    const data = await response.json();
if (subdomain === 'demo' && 
enable_2fa_google_auth == true 
      || enable_2fa_for_admin_passkeys == true || enable_2fa_for_admin_email == true
      || enable_2fa_for_admin_sms == true) {

        enable_2fa_for_admin_passkeys = false
        enable_2fa_for_admin_email = false
        enable_2fa_for_admin_sms = false
        enable_2fa_google_auth = false
        toast.error('demo mode does not allow admin settings update', {
          position: "top-center",
          duration: 4000,
        })


  
} else {

       if (response.ok) {
      toast.success('admin settings updated successfully', {
        position: "top-center",
        duration: 4000,
      })
      setisloading(false)
      setOpen(false)
      setOpenSettings(true)
      const {enable_2fa_for_admin_email, enable_2fa_for_admin_sms, send_password_via_sms,
        send_password_via_email, check_is_inactive,
        enable_2fa_for_admin_passkeys,
        checkinactiveminutes, checkinactivehrs,checkinactivedays} = data
      setAdminSettings(prevData => ({
        ...prevData, 
        enable_2fa_for_admin_email, enable_2fa_for_admin_sms, send_password_via_sms,
        enable_2fa_for_admin_passkeys,
        send_password_via_email, check_is_inactive,
        checkinactiveminutes, checkinactivehrs,checkinactivedays
      }));

    } else {
      setisloading(false)
      setOpen(false)
      setOpenSettings(false)
      toast.error('failed to update admin settings', {
        position: "top-center",
        duration: 4000,
      })
   
    }  
}

    
   
  } catch (error) {
    setisloading(false)
    setOpen(false)
    setOpenSettings(false)
    toast.error(
      'Error updating  admin settings server error',

    )
  }
}



const handleGetSmsProviderSettings = useCallback(
  async() => {
    


    try {
      const response = await fetch(`/api/sms_provider_settings`, {
        headers: {
          'Content-Type': 'application/json',
          'X-Subdomain': subdomain,
        },
      });

      const newData = await response.json()
      if (response.ok) {
        setSmsProvider({...sms_provider, sms_provider: newData[0].sms_provider})

      } else {
        if (response.status === 402) {
        setTimeout(() => {
          // navigate('/license-expired')
          window.location.href='/license-expired'
         }, 1800);
        
      }
if (response.status === 401) {
  toast.error(newData.error, {
    position: "top-center",
    duration: 4000,
  })
   setTimeout(() => {
          // navigate('/license-expired')
          window.location.href='/signin'
         }, 1900);
}
        toast.error('failed to fetch sms provider settings', {
          duration: 2000,
          position: 'top-center',
        })
      }
    } catch (error) {
      console.log(error)
    }
  },
  [],
)


useEffect(() => {
  handleGetSmsProviderSettings()
  
}, [handleGetSmsProviderSettings]);


const saveSmsProviderSetting = async(e) => {
  e.preventDefault()

  try {
    const response = await fetch('/api/sms_provider_settings', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Subdomain': subdomain,
      },
      body: JSON.stringify({
        sms_provider_setting: sms_provider
      })
    })

    const newData = await response.json()
    if (response.ok) {
      toast.success('SMS settings updated successfully', {
        duration: 4000,
        position: "top-center",
      })
      console.log('updated sms settings', newData)
      setSmsProvider({...sms_provider, sms_provider: newData.sms_provider})
    } else {
      toast.error('failed to update sms settings', {
        duration: 4000,
        position: "top-center",
      })
    }
  } catch (error) {
    toast.error('error updating sms settings', {
      duration: 4000,
      position: "top-center",
    })
  }

} 










const fetchSavedSmsSettings = useCallback(
  async() => {
    
    try {
      const response = await fetch(`/api/saved_sms_settings`, {
        headers: {
          'Content-Type': 'application/json',
          'X-Subdomain': subdomain,
        },
      });
  
      const data = await response.json();

     
  
      if (response.ok) {
      
        setSmsProviders(data)
      } else {
       if (response.status === 402) {
        setTimeout(() => {
          // navigate('/license-expired')
          window.location.href='/license-expired'
         }, 1800);
        
      }
if (response.status === 401) {
  toast.error(data.error, {
    position: "top-center",
    duration: 4000,
  })
   setTimeout(() => {
          // navigate('/license-expired')
          window.location.href='/signin'
         }, 1900);
}
      }
    } catch (error) {
      toast.error('Internal server error: Something went wrong with fetching SMS settings', {
        duration: 3000,
        position: 'top-center',
      });
    }
  },
  [],
)


useEffect(() => {
  fetchSavedSmsSettings();
 
}, [fetchSavedSmsSettings]);




const saveSubcriberSettings = async(e) => {
  e.preventDefault()
  try {
    setisloading(true)
    setOpen(true)
    const response = await fetch('/api/subscriber_settings', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Subdomain': subdomain,
        
        
      },
      body: JSON.stringify({
       subscriber_setting: subscriberSettings
      })
    })
const newData = await response.json()
    if(response.ok){

setSubscriberSettings(
  {...subscriberSettings, prefix:newData.prefix, minimum_digits: newData.minimum_digits, 
   use_autogenerated_number_as_ppoe_username: newData.use_autogenerated_number_as_ppoe_username,
   notify_user_account_created: newData.notify_user_account_created,
   send_reminder_sms_expiring_subscriptions: newData.send_reminder_sms_expiring_subscriptions,
   account_number_starting_value: newData.account_number_starting_value,
   use_autogenerated_number_as_ppoe_password: newData.use_autogenerated_number_as_ppoe_password
  }
)

setisloading(false)
setOpen(false)
setOpenSettings(true)

toast.success('subscriber settings successfully saved', {
  position: "top-center",
  duration: 4000,
})

    }else{
      setisloading(false)
      setOpen(false)
      setOpenSettings(false)
      toast.error('failed to save subscriber settings',
        {
          position: 'top-center',
          duration: 3000,
        }
      )
    }
  } catch (error) {
    setisloading(false)
    setOpen(false)
    setOpenSettings(false)
    toast.error(
      'internal server error while saving subscriber settings',
      {
        position: 'top-center',
        duration: 3000,
      }
    )
  } 
}




const fetchSubscriberSettings = useCallback(
  async() => {
    try {
      const response = await fetch('/api/subscriber_settings',{
        headers: {
          'X-Subdomain': subdomain,
        },
      })

      const newData = await response.json()
      if (response.ok){


const {

  prefix,
  minimum_digits,
  use_autogenerated_number_as_ppoe_username,
  notify_user_account_created,
  send_reminder_sms_expiring_subscriptions,
  account_number_starting_value,
  use_autogenerated_number_as_ppoe_password
} = newData[0]



setSubscriberSettings(
  {...subscriberSettings, prefix:prefix, minimum_digits:minimum_digits, 
   use_autogenerated_number_as_ppoe_username: use_autogenerated_number_as_ppoe_username,
   notify_user_account_created: notify_user_account_created,
   send_reminder_sms_expiring_subscriptions: send_reminder_sms_expiring_subscriptions,
   account_number_starting_value: account_number_starting_value,
   use_autogenerated_number_as_ppoe_password: use_autogenerated_number_as_ppoe_password
  }
)
      }else{
if (response.status === 402) {
        setTimeout(() => {
          // navigate('/license-expired')
          window.location.href='/license-expired'
         }, 1800);
        
      }
if (response.status === 401) {
  toast.error(newData.error, {
    position: "top-center",
    duration: 4000,
  })
   setTimeout(() => {
          // navigate('/license-expired')
          window.location.href='/signin'
         }, 1900);
}
toast.error(newData.error, {
position: "top-center",
duration: 5000,
})

// toast.error('failed to fetch subscriber settings', {
//   position: "top-center",
//   duration: 4000,
// })  
      }
    } catch (error) {
      // toast.error('failed to fetch subscriber settings server error', {
      //   position: "top-center",
      //   duration: 4000,
      // })  
    }
  },
  [],
)



useEffect(() => {
  fetchSubscriberSettings()
}, [fetchSubscriberSettings]);



const Button = styled(motion.button)`
margin-top: 30px;
padding: 10px 26px;
font-size: 0.9rem;
color: white;
background: black;
border: none;
border-radius: 25px;
cursor: pointer;
box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);

&:hover {
  background: green;
}
`;



const StyledAccordion = motion(Accordion);
const StyledButton = motion(Button);
const [showSuccess, setShowSuccess] = useState(false);


const SettingsCheckbox = ({ label, description, checked, onChange, name }) => (
  <div className="mb-4 p-4  rounded-lg shadow-sm">
    <FormControlLabel
      className="dark:text-white text-black mb-1"
      control={
        <Checkbox 
          checked={checked}
          onChange={onChange}
          name={name}
          color="default"
        />
      }
      label={<span className="font-medium">{label}</span>}
    />
    <p className="ml-8 text-sm text-black dark:text-white">
      {description}
    </p>
  </div>
);
  return (

    <>
     {/* {children} */}
     <Suspense fallback={<div className='flex justify-center items-center'>{ <UiLoader/> }</div>}>
    {/* <GeneralContext.Provider > */}
    <Toaster />
<Backdrop  handleClose={handleClose}  open={open}/>
<SettingsNotification open={openNotifactionSettings} handleClose={ handleCloseNotifaction }/>



<Accordion>
<AccordionSummary
          expandIcon={
            <ArrowDownwardIcon
            className='  text-black dark:text-white'
            />
          }
          aria-controls="panel1-content"
          id="panel1-header"
          sx={{
            backgroundColor: "rgba(0, 0, 0, 0.05)",
            borderRadius: "10px",
            color: "black",
          }}
        >
          <Typography variant="h6">
          <motion.div
          style={{ display: "flex", alignItems: "center", gap: "10px" }}
                  whileHover="hover"
                  whileTap="tap"
                >
                  <FiUsers
                  className='dark:text-white text-black'
                  />
                  <p className='dark:text-white roboto-condensed  text-black
                  text-lg
                  '>User Registration</p>
                </motion.div>
            
            
            </Typography>
        </AccordionSummary>
        <AccordionDetails
          sx={{
            backgroundColor: "rgba(0, 0, 0, 0.05)",
            borderRadius: "10px",
            marginTop: "10px",
            padding: "20px",
          }}
        >
<form onSubmit={handleChangeAdminSetting}>
  <motion.div    transition={{duration:0.5, ease: "easeInOut",
  }} initial='hidden'  id="" 
  className={`
   `}
   >
    <div className="p-5 border border-b-0 border-gray-200 ">
   

    <SettingsCheckbox
    checked={enable_2fa_for_admin_sms}
      label= {<p>Enable Two-Factor Authentication SMS(2FA) (<p className='font-bold'>experimental 
      dont try this for now,
        incase of any eror arising from this setting dont hesitate to call support </p>
        

        ) <IoWarningOutline className='text-red-800 
        w-5 h-5 inline-block align-middle'/></p>}
      description="When enabled, administrators will receive a one-time 
      password via SMS during two-factor authentication login. This adds an extra layer of security by requiring both password and SMS verification."
      onChange={handleChangeAdminSettings}
      value={enable_2fa_for_admin_sms}
      name="enable_2fa_for_admin_sms"
    />

    <SettingsCheckbox
    checked={enable_2fa_for_admin_email}
     onChange={handleChangeAdminSettings}
      label={<p>Enable Two-Factor Authentication Email(2FA) (<p className='font-bold'>experimental 
      dont try this for now,
        incase of any eror arising from this setting dont hesitate to call support </p>
        

        ) <IoWarningOutline className='text-red-800 
        w-5 h-5 inline-block align-middle'/>   </p>}
      description="When enabled, administrators will receive a one-time password via email during two-factor authentication login. This provides an alternative verification method using email instead of SMS."
     value={enable_2fa_for_admin_email}
      name="enable_2fa_for_admin_email"
    />

<SettingsCheckbox
    checked={enable_2fa_for_admin_passkeys}
     onChange={handleChangeAdminSettings}
      label="Enable Two-Factor Authentication Passkeys(2FA)"
      description="When enabled, administrators can use passkeys as a secure alternative to traditional two-factor authentication methods. Instead of receiving a one-time password via SMS, authentication is completed using a biometric scan (like Face ID or fingerprint) or a device-based prompt,
       leveraging public-key cryptography. This method enhances security and simplifies the login experience."


     value={enable_2fa_for_admin_passkeys}
      name="enable_2fa_for_admin_passkeys"
    />


<SettingsCheckbox
    checked={enable_2fa_google_auth}
     onChange={handleChangeAdminSettings}
      label="Enable Two-Factor Authentication Google Authenticator(2FA)"
      description="When enabled, administrators can authenticate using Google Authenticator, a widely-used two-factor authentication (2FA) method based on time-based one-time passwords (TOTP). After entering their primary login credentials, users are prompted to enter a 6-digit code generated by the Google Authenticator app on their mobile device. This code changes every 30 seconds and is uniquely tied to the user's secret key. This adds an extra layer of security by ensuring that access requires something the user knows (password) and something the user has (mobile device), 
      significantly reducing the risk of unauthorized access due to stolen passwords."
     value={enable_2fa_google_auth}
      name="enable_2fa_google_auth"
    />

  

   

   


      <Box
       className='dark:text-black myTextField'
      component="form"
      sx={{
        '& .MuiTextField-root': { m: 1, },
      }}
      noValidate
    >


{/* Admin Inactivity Settings */}
<div className="space-y-6 p-4  rounded-lg shadow-sm">
  <h3 className="text-lg font-medium text-black dark:text-white">Inactivity Timeout Settings</h3>
  
  <div className="space-y-4">
    <div className=' '>

    <SettingsCheckbox
      label="Logout an admin after a period of inactivity"
      description="When enabled, administrators will be logged out automatically after a specified period of inactivity."
      value={check_is_inactive}
      checked={check_is_inactive}
      onChange={handleChangeAdminSettings}
      name="check_is_inactive"
    />
      <TextField 
      

        sx={{
          width: '100%',

          '& label.Mui-focused': {
            color: 'black',
            fontSize:'16px'
          },
          '& .MuiOutlinedInput-root': {
            "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
              borderColor: "black",
              borderWidth: '3px'
            },
            '&.Mui-focused fieldset': {
              borderColor: 'black',
            }
          },
        }}
        id="inactive-hours"
        label="Logout After Inactivity (Hours)"
        type="number"
        onChange={handleChangeAdminSettings}
        name="checkinactivehrs"
       value={checkinactivehrs}
        helperText={
        <p className='dark:text-white text-black text-lg md:w-full md:text-sm  text-wrap w-[140px]'>Automatically log out administrators after
        this many hours of inactivity. Enter 0 to disable hour-based logout.</p>}


      />
    </div>

    <div>
      <TextField 
        sx={{
          width: '100%',
          '& label.Mui-focused': { color: 'black' },
          '& .MuiOutlinedInput-root': {
            "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
              borderColor: "black",
              borderWidth: '3px'
            }
          }
        }}
        id="inactive-days"
        label="Logout After Inactivity (Days)"
        type="number"
        onChange={handleChangeAdminSettings}
        name="checkinactivedays"
      value={checkinactivedays} 
        helperText=
        {
          <p className='dark:text-white text-black text-lg md:w-full md:text-sm  text-wrap w-[140px]'>Automatically log out administrators after this many days of inactivity.
           Useful for long-term security. Enter 0 to disable day-based logout</p>}
      />
    </div>

    <div>
      <TextField 
        sx={{
          width: '100%',
          '& label.Mui-focused': { color: 'black' },
          '& .MuiOutlinedInput-root': {
            "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
              borderColor: "black",
              borderWidth: '3px'
            }
          }
        }}
        id="inactive-minutes"
        label="Logout After Inactivity (Minutes)"
        type="number"
        onChange={handleChangeAdminSettings}
        name="checkinactiveminutes"
        value={checkinactiveminutes}
        helperText={<p className='dark:text-white text-black text-lg md:w-full md:text-sm  text-wrap w-[140px]'>Automatically log out administrators after this many minutes of inactivity.
         Recommended for high-security environments. Enter 0 to disable minute-based logout</p>}
      />
    </div>
  </div>

  <div className="bg-gray-50 dark:bg-gray-700 p-4 rounded-md mt-4">
    <p className="text-sm text-black dark:text-gray-300">
      <strong className='text-black dark:text-white'>How it works:</strong> The system will log out administrators after any of these time periods are reached. 
      For example, setting 2 hours, 1 day, and 30 minutes will trigger a logout after either 2 hours, 1 day, or 30 minutes 
      of inactivity, whichever comes first.
    </p>
  </div>
</div>

{/* User Invitation Settings */}
<div className="space-y-6 p-4  rounded-lg shadow-sm mt-6">
  <h3 className="text-lg font-medium text-black dark:text-white">User Invitation Settings</h3>

  <div className="space-y-4">
    <div className="p-4  rounded-md">
      <FormControlLabel
        className="mb-2"
        control={
          <Checkbox
          checked={send_password_via_email}
          onChange={handleChangeAdminSettings}
            name="send_password_via_email"
            color="default"
          />
        }
        label={
          <div>
            <p className="font-medium text-black dark:text-white">Send Invite Via Email</p>
            <p className="text-sm text-black dark:text-white mt-1">
              When enabled, new users will receive their login credentials and initial password through email. 
              This is the recommended method for business email addresses.
            </p>
          </div>
        }
      />
    </div>

    <div className="p-4 rounded-md">
      <FormControlLabel
        className="mb-2"
        control={
          <Checkbox
             checked={send_password_via_sms}
          onChange={handleChangeAdminSettings}
            name="send_password_via_sms"
            color="default"
          />
        }
        label={
          <div>
            <p className="font-medium text-black dark:text-white">Send Invite Via SMS</p>
            <p className="text-sm text-black dark:text-white mt-1">
              When enabled, new users will receive their login credentials and initial password through SMS. 
              This method ensures immediate delivery to mobile devices and is useful when email access is limited.
            </p>
          </div>
        }
      />
    </div>
  </div>

  <div className="bg-yellow-50 dark:bg-yellow-900 p-4 rounded-md mt-4">
    <p className="text-sm text-yellow-800 dark:text-yellow-200">
      <strong>Security Note:</strong> It's recommended to enable at least one invitation method to ensure 
      new users can securely receive their login credentials. For maximum security, consider enabling both 
      methods for critical user accounts.
    </p>
  </div>
</div>

        </Box>

      



       <Tooltip title={<p className='text-lg'>users will be invited to the system via email and they will use passkeys during authentication(login)
       </p>}>
        <FormControlLabel
        
        className='dark:text-white text-black'
         name='login_with_web_auth'  control={<Checkbox color="default"
          />  } 
        label="Invite users with email(users will be invited to the system via passkeys)" />
       </Tooltip>


<div className='p-5'>
<Button
        whileHover={{ scale: 1.1 }}
        whileTap={{ scale: 0.9 }}
      >
        update settings
      </Button>


      

        </div>
    </div>
  </motion.div>
  </form>
  </AccordionDetails>
  </Accordion>


{/* 
<form onSubmit={handleUpdateSettings}>

<Accordion  sx={{
            backgroundColor: 'transparent',
          }}>
        <AccordionSummary
          expandIcon={<ArrowDownwardIcon />}
          aria-controls="panel1-content"
          id="panel1-header"
         
        >
          <Typography>Router Management</Typography>
        </AccordionSummary>
        <AccordionDetails>

          <Typography>
          

          <Autocomplete
                      value={routers.find((router)=> router.name === settingsformData.router_name)|| null}

  sx={{
width:{
  xs: '55%'
},
    '& label.Mui-focused': {
      color: 'black',
      fontSize:'16px'
      },
    '& .MuiOutlinedInput-root': {
    "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
      borderColor: "black",
      borderWidth: '3px'
      },
    '&.Mui-focused fieldset':  {
      borderColor: 'black', 
    
    }
    },
             
            }} 

            
                  getOptionLabel={(router) => router.name}

        options={routers}
        
                renderInput={(params) => (
                  <TextField
                  id="router_name"
                  getOptionValue={(option) => option.id}   

                  className='myTextField'
                    {...params}
                    label="Select Router"
                 

                   
                  />
                  
                )}
              
                onChange={(event, newValue) => {
                  console.log("Selected Router:", newValue);

                  setFormData({...settingsformData, router_name: newValue ? newValue.name : '' });
                }}

                renderOption={(props, routerName) => (
                  <Stack
                    direction='row'
                    spacing={2}
                    sx={{
                      width: '100%',
                      padding: 1,
                      '&:hover': {
                        backgroundColor: 'rgba(0, 0, 0, 0.1)',
                        display: 'flex',
                        flexDirection: 'start'
                      }
                    }}
                    {...props}
                  >
                   <img  className='w-[60px] h-[50px]' src="/images/icons8-router-80.png" alt="router" />
                    <Stack direction='column'>
                    <span>{routerName.name}</span>
                    </Stack>
                  
                  </Stack>
                  
                )}
              />

          </Typography>


          <Button
        whileHover={{ scale: 1.1 }}
        whileTap={{ scale: 0.9 }}
      >
        update settings
      </Button>
        </AccordionDetails>
      </Accordion>

      </form> */}








<form onSubmit={saveSmsProviderSetting}>
      <Accordion
        sx={{
          backgroundColor: "transparent",
          boxShadow: "none",
        }}
      >
        <AccordionSummary
          expandIcon={
            <ArrowDownwardIcon
            className='dark:text-white text-black'
              sx={{  transition: "transform 0.3s" }}
            />
          }
          aria-controls="panel1-content"
          id="panel1-header"
          sx={{
            backgroundColor: "rgba(0, 0, 0, 0.05)",
            borderRadius: "10px",
            color: "black",
          }}
        >
          <Typography variant="h6">
            <div className='flex gap-3'>
            <MdTextsms className='text-green-500'/>
            <p className='dark:text-white text-black text-lg roboto-condensed '>Sms settings</p>
              
            </div>
            
            
            </Typography>
        </AccordionSummary>

        
        <AccordionDetails
          sx={{
            backgroundColor: "rgba(0, 0, 0, 0.05)",
            borderRadius: "10px",
            marginTop: "10px",
            padding: "20px",
          }}
        >
          <Typography className='roboto-condensed'  variant="body1" sx={{ mb: 2 }}>
            <strong className='roboto-condensed-bold'>What does this setting do?</strong>
            <br />
            <p className=''>This setting allows you to select a user to input systemwide sms settings</p>
          </Typography>

          <Autocomplete
         
            value={
              smsProviders.find((provider) => provider.sms_provider === sms_provider.sms_provider) ||
              null
            }
            sx={{
              width: { xs: "100%", sm: "55%" },
              "& label.Mui-focused": {
                color: "black",
                fontSize: "16px",
              },
              "& .MuiOutlinedInput-root": {
                "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
                  borderColor: "black",
                  borderWidth: "3px",
                },
                "&.Mui-focused fieldset": {
                  borderColor: "black",
                },
              },
            }}
            getOptionLabel={(sms_provider) => sms_provider.sms_provider}
            options={smsProviders}
            renderInput={(params) => (
              <TextField
              InputProps={{
                StartAdornment: <MdTextsms className='mr-2'/>
              }}
                name='sms_provider'
                className="myTextField"
                {...params}
                label="Select Sms Provider"
              />
            )}
            onChange={(event, newValue) => {
              console.log("Selected Router:", newValue);

              setSmsProvider({...sms_provider, sms_provider: newValue ? newValue.sms_provider : '' });
            }}
            renderOption={(props, sms_provider) => (
              <Stack
            
                direction="row"
                spacing={2}
                sx={{
                  width: "100%",
                  padding: 1,
                  "&:hover": {
                    backgroundColor: "rgba(0, 0, 0, 0.1)",
                  },
                }}
                {...props}
              >
                <MdTextsms  />
                <Stack direction="column">
                  <span>{sms_provider?.sms_provider}</span>
                </Stack>
              </Stack>
            )}
          />

          {showSuccess && (
            <motion.div
              initial={{ opacity: 0, y: -20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.5 }}
              style={{
                display: "flex",
                alignItems: "center",
                marginTop: "10px",
                color: "#4CAF50",
              }}
            >
              <CheckCircleIcon sx={{ mr: 1 }} />
              <Typography variant="body1">
                sms provider selected successfully! Settings applied system-wide.
              </Typography>
            </motion.div>
          )}

        

          <Tooltip title="Update router settings system-wide">
            <Button
              type="submit"
              sx={{
                marginTop: "20px",
                padding: "10px 20px",
                backgroundColor: "#ff6f61",
                color: "white",
                borderRadius: "25px",
                "&:hover": {
                  backgroundColor: "#ff4a3d",
                },
              }}
              whileHover={{ scale: 1.1 }}
              whileTap={{ scale: 0.9 }}
              component={motion.button}
            >
              Update Settings
            </Button>
          </Tooltip>
        </AccordionDetails>
      </Accordion>
    </form>
















<form onSubmit={handleUpdateSettings}>
      <Accordion
        sx={{
          backgroundColor: "transparent",
          boxShadow: "none",
        }}
      >
        <AccordionSummary
          expandIcon={
            <ArrowDownwardIcon
            className='dark:text-white text-black'
              sx={{  transition: "transform 0.3s" }}
            />
          }
          aria-controls="panel1-content"
          id="panel1-header"
          sx={{
            backgroundColor: "rgba(0, 0, 0, 0.05)",
            borderRadius: "10px",
            color: "black",
          }}
        >
          <Typography variant="h6">
            <div className='flex gap-3'>
            <BsRouter className='text-red-500'/>
            <p className='dark:text-white text-black text-lg roboto-condensed'>Router Management</p>
              
            </div>
            
            
            </Typography>
        </AccordionSummary>

        
        <AccordionDetails
          sx={{
            backgroundColor: "rgba(0, 0, 0, 0.05)",
            borderRadius: "10px",
            marginTop: "10px",
            padding: "20px",
          }}
        >
          <Typography className='' variant="body1" sx={{ mb: 2 }}>
            <strong className='roboto-condensed roboto-condensed-bold'>What does this setting do?</strong>
            <br />
            <p className='roboto-condensed'>This setting allows you to select a router that will be applied
            system-wide. Choosing the correct router ensures effective
            communication between your system and the router, optimizing network </p>
            performance.
          </Typography>

          <Autocomplete
         
            value={
              routers.find((router) => router.name === settingsformData.router_name) ||
              null
            }
            sx={{
              width: { xs: "100%", sm: "55%" },
              "& label.Mui-focused": {
                color: "black",
                fontSize: "16px",
              },
              "& .MuiOutlinedInput-root": {
                "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
                  borderColor: "black",
                  borderWidth: "3px",
                },
                "&.Mui-focused fieldset": {
                  borderColor: "black",
                },
              },
            }}
            getOptionLabel={(router) => router.name}
            options={routers}
            renderInput={(params) => (
              <TextField
              InputProps={{
                StartAdornment: <BsRouter className='mr-2'/>
              }}
                id="router_name"
                className="myTextField"
                {...params}
                label="Select Router"
              />
            )}
            onChange={(event, newValue) => {
              console.log("Selected Router:", newValue);

              setFormData({...settingsformData, router_name: newValue ? newValue.name : '' });
            }}
            renderOption={(props, router) => (
              <Stack
              InputProps={{
                StartAdornment: <BsRouter className='mr-2'/>
              }}
                direction="row"
                spacing={2}
                sx={{
                  width: "100%",
                  padding: 1,
                  "&:hover": {
                    backgroundColor: "rgba(0, 0, 0, 0.1)",
                  },
                }}
                {...props}
              >
                <img
                  className="w-[60px] h-[50px]"
                  src="/images/icons8-router-80.png"
                  alt="router"
                />
                <Stack direction="column">
                  <span>{router.name}</span>
                </Stack>
              </Stack>
            )}
          />

          {showSuccess && (
            <motion.div
              initial={{ opacity: 0, y: -20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.5 }}
              style={{
                display: "flex",
                alignItems: "center",
                marginTop: "10px",
                color: "#4CAF50",
              }}
            >
              <CheckCircleIcon sx={{ mr: 1 }} />
              <Typography variant="body1">
                Router selected successfully! Settings applied system-wide.
              </Typography>
            </motion.div>
          )}

        

<Tooltip title={<p className='text-lg'>
  RADIUS authentication and accounting gives the ISP or network administrator ability to
   manage PPP user access and accounting from one server throughout a large network.
       </p>}>
        <FormControlLabel  className='dark:text-white text-black'
         name='use_radius'  control={<Checkbox color="default"
          checked={settingsformData.use_radius}
          onChange={handleChange}
          />  } 
          label={
            <div>
              <p className="font-medium text-black dark:text-white">use radius authentication</p>
              <p className="text-sm text-black dark:text-white mt-1">
              Manage pppoe 
              authentication and accounting from one server throughout a large network
              </p>
            </div>
          } />
       </Tooltip>
          <Tooltip title="Update router settings system-wide">
            <Button
              type="submit"
              sx={{
                marginTop: "20px",
                padding: "10px 20px",
                backgroundColor: "#ff6f61",
                color: "white",
                borderRadius: "25px",
                "&:hover": {
                  backgroundColor: "#ff4a3d",
                },
              }}
              whileHover={{ scale: 1.1 }}
              whileTap={{ scale: 0.9 }}
              component={motion.button}
            >
              Update Settings
            </Button>
          </Tooltip>
        </AccordionDetails>
      </Accordion>
    </form>




















      <form onSubmit={saveSubcriberSettings} className='mt-4'>
      <Accordion   sx={{
            backgroundColor: 'transparent',
          }}>
        <AccordionSummary
          expandIcon={
            <ArrowDownwardIcon
            className='dark:text-white text-black'
              sx={{  transition: "transform 0.3s" }}
            />
          }
          aria-controls="panel1-content"
          id="panel1-header"
          sx={{
            backgroundColor: "rgba(0, 0, 0, 0.05)",
            borderRadius: "10px",
            color: "black",
          }}
        >
          <Typography variant="h6">
            <div className='flex gap-3 text-amber-800'>

              <CiUser />
              <p className='dark:text-white text-black
               text-lg roboto-condensed'>Fixed Subscriber Account</p>
            </div>
           
            
            </Typography>
        </AccordionSummary>
        <AccordionDetails
         sx={{
          backgroundColor: "rgba(0, 0, 0, 0.05)",
          borderRadius: "10px",
          marginTop: "10px",
          padding: "20px",
        }}
        >

          <Typography>

            <FormGroup>
            <div className='flex '>

          <FormControlLabel     sx={{
            width:{
              xs: '65%',
              sm: '60%',
              md: '60%',
              lg: '30%',
              xl:'30%'
            }
          }}   control={<Checkbox color="default"/>} 
          label="Only Show Packages for Current Zone/Subdomain on homepage" />
          <Tooltip  classes={{
          tooltip: classes.customTooltip,
          arrow: classes.customArrow
        }} sx={{
            width: '20%',
            background: 'red'
          }}  title={<p className='text-lg font-extrabold'>Zone as subdomain <span className='font-extralight  text-sm font-mono'>
Show only the subscription packages to a particular area/zone. Feature is only available for isps who
 have custom domains setup for the portal. Contact us at +254791568852 for setup
            </span></p>} enterDelay={500} leaveDelay={200}>
 
          <Stack sx={{ width: 0 , display: 'flex', justifyContent: 'center'}} spacing={2}>
      <Alert sx={{background: 'transparent'}}  severity="info"></Alert>
     
    </Stack>
    </Tooltip>
    </div>
 

    <FormControlLabel      sx={{
            width:{
              xs: '65%',
              sm: '60%',
            },
            marginTop: 2
            
          }}  control={<Checkbox color="default"/>} label="Notify Customer After Sucesful Subscription Renewal" />

<div className='flex'>
    <FormControlLabel sx={{
       width:{
        xs: '25%',
        sm: '30%',
        marginTop: 30
      }
    }}  control={<Checkbox  color="default" />} label="Email Receipt To Customer On Sucessful Subscription Renewal" />

    <Tooltip title={<p className='text-lg font-extrabold'>Email Setup Required
         <span className='font-extralight  text-sm font-mono'>  Email must be set up in the EMAIL settings tab for receipts 
to be automatically emailed</span></p>} enterDelay={500} leaveDelay={200}>
 
          <Stack sx={{ width: 0 , display: 'flex', justifyContent: 'center'}} spacing={2}>
      <Alert sx={{background: 'transparent'}} severity="info"></Alert>
     
    </Stack>
    </Tooltip>
    </div>
    <FormControlLabel sx={{
       width:{
        xs: '25%',
        sm: '30%',
        marginTop: 20
        
      }
    }}  control={<Checkbox color="default" />} label="Automatically Send Reminder SMS for Expiring Subscriptions"  />
    <Box
              className='myTextField'

      component="form"
      sx={{
        '& .MuiTextField-root': { m: 1, width: {
          sm: '50ch',
          xs: '25ch',
          md:'60ch',
          lg: '100ch',
          xl: '130ch'
        }, 
       },

  '& label.Mui-focused': {
    color: 'black'
    },

'& .MuiOutlinedInput-root': {
  
  "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
    borderColor: "black",
    borderWidth: '3px'
    },
 '&.Mui-focused fieldset':  {
    borderColor: 'black', // Set border color to transparent when focused

  }
},
      }}
      noValidate
    >
  <TextField
          
          label="Reminder Intervals"
          helperText="Enter Days to/after expiry when reminders should be sent separated by
           commas e.g 5,2,1,0,+2,+4 to send reminders at 5,2, or 1 day to expiry, on the day of expiry and 
           for subscriptions that expired 2 or 4 days ago.

          "
        />

        </Box>


        <FormControlLabel  control={<Checkbox color="default"/>} label="Send Reminder On the Same Date Every Month"  />
        <FormControlLabel  control={<Checkbox color="default"/>} label="Set Expiry date of 30 day fixed/home
         subscriptions to same date (leave unchecked to only add 30 days to subscription)"  />
 <FormControlLabel  control={<Checkbox  color="default"/>} label="Create Partial Subscription for Partial
  Payments (Extend subscription by number of days corressponding to amount paid if partial payment)"  />
<FormControlLabel  control={<Checkbox color="default"
checked={use_autogenerated_number_as_ppoe_username}
onChange={handleChangeSubscriberSettings}
name='use_autogenerated_number_as_ppoe_username'
/>} label="Use Auto Generated Account Number As PPOE username"  />


<FormControlLabel  control={<Checkbox  color="default"/>} label="Notify User Once Their Account Is Created"  />
<FormControlLabel  control={<Checkbox color="default" />} label="Use Node Code As Account Prefix"  />

</FormGroup>

        <Stack direction='row'   sx={{
        '& .MuiTextField-root': { m: 1, width: '90ch',    '& label.Mui-focused': {
          color: 'black',
          fontSize: '16px'
          },
      '& .MuiOutlinedInput-root': {
        "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
          borderColor: "black",
          borderWidth: '3px',
          },
       '&.Mui-focused fieldset':  {
          borderColor: 'black', 
          
        }
      } },
      }}   spacing={{
          xs: 1,
          sm: 2
        }}>

          <TextField  name='prefix' className='myTextField' onChange={handleChangeSubscriberSettings} value={prefix}
          label='Subscriber Account No Prefix' ></TextField>
          <TextField name='minimum_digits'  className='myTextField'   onChange={handleChangeSubscriberSettings}
           value={minimum_digits} 
             type='number'  label='Subscriber Account No Minimum Digits(Zeros will be added to the front, eg SUB001 for three digits)'></TextField>

        </Stack>



          <div className='border-2  dark:border-black  shadow-xl lg:h-[280px]  sm:h-[400px]   max-md:h-[500px]  max-sm:h-[600px] ,
           flex justify-center items-center flex-col gap-y-2 p-1'>
          <Stack  sx={{
            width: {
              sm: '40ch',
              lg: '110ch',
              xl: '150ch'
            },

           marginBottom:  {
sm: '120px',
lg: '55px',
xs: '30ch'
            },

            height: {
              sm: '10ch',
              xs: '1ch'
            }
          }}>
    
      <Alert severity="info">
        <AlertTitle>Set Account No. Counter Starting Value</AlertTitle>
        Use this to set the value from which the account number counter should start from. Run once after importing a list of customers to make sure account numbers continue from the uploaded values. Set the values of the highest account number.
.
      </Alert>
     
    </Stack>

<Box  sx={{
        '& .MuiTextField-root': { m: 1, width: {sm: '35ch', lg: '95ch', xl: '130ch' },   '& label.Mui-focused': {
          color: 'black',
          fontSize: '16px'
          },
      '& .MuiOutlinedInput-root': {
        "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
          borderColor: "black",
          borderWidth: '3px',
          },
       '&.Mui-focused fieldset':  {
          borderColor: 'black', 
          
        }
      } },
      }}>
<TextField    label='Current Account(exclude prefix)'     className='myTextField'></TextField>

</Box>

          </div>


        <FormGroup sx={{
        }}>
     
      <FormControlLabel  control={<Checkbox  color="default" checked={use_autogenerated_number_as_ppoe_password} 
       onChange={handleChangeSubscriberSettings}  name='use_autogenerated_number_as_ppoe_password'/>} 
         label="Use Auto-Generated Customer PPPoE Password" />
      <FormControlLabel control={<Checkbox color="default"/>}  color="default" label="Lock PPPoE account to the MAC Address detected on 
      first dial (The first MAC Address detected will be saved as the accounts Sticky MAC address and must
         be deleted to switch to a new device)"
 />
      <FormControlLabel control={<Checkbox  color="default"/>} label="Allow Subscriber accounts to have more than one client device" />
      <FormControlLabel control={<Checkbox  color="default"/>} label="Use the same Username/Password for
       all devices in a multidevice account" />
      <FormControlLabel control={<Checkbox  color="default"/>} label="Automatically Redeem points when redeemable amount is reached" />

    </FormGroup>


          <Stack direction='row'>

            {/* <Button  className='mt-7'type='submit'  loading={isloading} startIcon={<AutorenewIcon/>}
              >Update General Settings</Button> */}


<Button
type='submit'
        whileHover={{ scale: 1.1 }}
        whileTap={{ scale: 0.9 }}
      >
        update settings
      </Button>
          </Stack>

          </Typography>
        </AccordionDetails>
      </Accordion>
      </form>






      <form onSubmit={handleCreateCompanySettings}>

<Accordion  sx={{
            backgroundColor: 'transparent',
          }}>
      <AccordionSummary
       className='bg-slate-200 dark:bg-slate-900 rounded-2xl shadow-sm'
          expandIcon={
            <ArrowDownwardIcon
            className='dark:text-white text-black
            '
              sx={{  transition: "transform 0.3s" }}
            />
          }
          aria-controls="panel1-content"
          id="panel1-header"
          sx={{
            borderRadius: "10px",
            color: "black",
          }}
         
        >
          <Typography variant="h6">
            
            <div className='flex gap-3 '>
              <FaRegBuilding className='text-cyan-600'/>
            <p className='dark:text-white text-black text-lg roboto-condensed'>Company Settings</p>
            </div>
            </Typography>
            
        </AccordionSummary>
        <AccordionDetails
        className='bg-slate-200 dark:bg-slate-900 p-4 rounded-lg shadow-sm'
         sx={{
          // backgroundColor: "rgba(0, 0, 0, 0.05)",
          borderRadius: "10px",
          marginTop: "10px",
          padding: "20px",
        }}
        >

          <Typography>
          
          <Stack direction='column' className='myTextField' sx={{
          '& .MuiTextField-root': { 
            m: 1, 
            marginTop: '30px',  
            '& label.Mui-focused': {
              color: 'black',
              fontSize: '16px'
            },
            '& .MuiOutlinedInput-root': {
              "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
                borderColor: "black",
                borderWidth: '3px'
              },
              '&.Mui-focused fieldset': {
                borderColor: 'black',
              }
            } 
          },
        }} spacing={{xs: 1, sm: 2}}>

          {/* Existing text fields */}
          <TextField  
          InputProps={{
            startAdornment: <FaRegBuilding className='mr-2'/>

          }}
            name='company_name'
            value={company_name}
            onChange={handleFormDataChangeForCompany}
            label='Company Name' 
            type='text'
          />

          <TextField  
          InputProps={{
            startAdornment: <MdOutlineMailOutline className='mr-2'/>

          }}
            onChange={handleFormDataChangeForCompany}
            name='email_info'
            value={email_info}
            label='Email Info' 
            type='text'
          />

          <TextField 
          InputProps={{
            startAdornment: <MdOutlinePhonelinkSetup className='mr-2'/>
          }} 
            onChange={handleFormDataChangeForCompany}
            name='contact_info'
            value={contact_info}
            label='Company Contact Info' 
            type='text'
          />


<TextField  
            onChange={handleFormDataChangeForCompany}
            name='agent_email'
            InputProps={{
              startAdornment: <MdOutlineMailOutline className='mr-2'/>

            }}
            value={agent_email}
            label='Agent Email' 
            type='text'
          />


<TextField 
InputProps={{
  startAdornment: <FaPhone className='mr-2'/>
}} 
            onChange={handleFormDataChangeForCompany}
            name='customer_support_phone_number'
            value={customer_support_phone_number} 
            label='Customer Support Phone Number'
            type='text'
          />




<TextField  
            onChange={handleFormDataChangeForCompany}
            name='customer_support_email'
            value={customer_support_email}
            label='Customer Support Email'  
            type='text'
            InputProps={{
              startAdornment: <MdOutlineMailOutline className='mr-2'/>

            }}

          />

          {/* Add the new image upload section */}
          <div className="flex flex-col gap-4 p-4">
            <label className="text-lg font-medium  dark:text-white text-black roboto-condensed-bold">Company Logo</label>
            <input
              type="file"
              accept="image/*"
              onChange={handleImageChange}
              className="hidden"
              id="logo-upload"
            />
            
            <label 
              htmlFor="logo-upload"
              className="flex items-center justify-center p-4 border-2
               border-dashed border-gray-300 rounded-lg cursor-pointer
                hover:border-gray-400"
            >
              {companySettings.logo_preview ? (
                <div className="relative">
                  <img 
                    src={companySettings.logo_preview}
                    alt="Logo preview" 
                    className="max-w-xs max-h-48 object-contain"
                  />
                  <button
                    onClick={(e) => {
                      e.preventDefault();
                      setCompanySettings(prev => ({...prev, logo: null, logo_preview: null}));
                    }}
                    className="absolute top-0 right-0 bg-red-500 text-white p-1 rounded-full"
                  >
                    
                  </button>
                </div>
              ) : (
                <div className="text-gray-500">
                  <p className='dark:text-white text-black roboto-condensed'>Click to upload company logo</p>
                  <p className="text-sm dark:text-white text-black roboto-condensed-light">PNG, JPG up to 5MB</p>
                </div>
              )}
            </label>
          </div>

        </Stack>

         

          </Typography>


          {/* <Button className='mt-7'  type='submit'>Update General Settings</Button> */}
          <Button
          type='submit'
        whileHover={{ scale: 1.1 }}
        whileTap={{ scale: 0.9 }}
      >
        update settings
      </Button>
        </AccordionDetails>
      </Accordion>

      </form>


      {/* </GeneralContext.Provider > */}
      </Suspense >
     
      </>
   
  )
}

export default GeneralSettings
// export const useSettings = (()=> useContext(GeneralContext ))

