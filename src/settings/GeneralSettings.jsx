import Accordion from '@mui/material/Accordion';
import AccordionSummary from '@mui/material/AccordionSummary';
import AccordionDetails from '@mui/material/AccordionDetails';
import Typography from '@mui/material/Typography';
import ArrowDownwardIcon from '@mui/icons-material/ArrowDownward';
import ArrowDropDownIcon from '@mui/icons-material/ArrowDropDown';
import FormGroup from '@mui/material/FormGroup';
import FormControlLabel from '@mui/material/FormControlLabel';
import Checkbox from '@mui/material/Checkbox';
import Box from '@mui/material/Box';
import TextField from '@mui/material/TextField';
import Tooltip from '@mui/material/Tooltip';
import Backdrop from '../backdrop/Backdrop'
import Alert from '@mui/material/Alert';
import Stack from '@mui/material/Stack';
import AlertTitle from '@mui/material/AlertTitle';
import Autocomplete from '@mui/material/Autocomplete';
import { useDebounce } from 'use-debounce';
import styled from "styled-components";
import { motion } from "framer-motion";
import CheckCircleIcon from "@mui/icons-material/CheckCircle";


// import { Button } from "@/components/ui/button"

// import LoadingButton from '@mui/lab/LoadingButton';
import AutorenewIcon from '@mui/icons-material/Autorenew';
// import CloseIcon from '@mui/icons-material/Close';

import {useState, useEffect,  useCallback, useMemo,
  createContext, useContext,Suspense, lazy
} from 'react'
import { useApplicationSettings } from './ApplicationSettings';
import { makeStyles } from '@material-ui/core/styles';
const SettingsNotification = lazy(() => import('../notification/SettingsNotification'))

import toast, { Toaster } from 'react-hot-toast';
import UiLoader from '../uiloader/UiLoader'



const useStyles = makeStyles(theme => ({
  customTooltip: {
    backgroundColor: 'gray',
  },
  customArrow: {
    color: 'rgba(220, 0, 78, 0.8)',
  },
}));



const GeneralContext = createContext(null)


const GeneralSettings = ({children}) => {
  const { handleChange, settingsformData, isloading, setisloading,
     setFormData, companySettings, setCompanySettings,
     handleChangeSubscriberSettings,subscriberSettings,setSubscriberSettings
    } = useApplicationSettings();


     const {contact_info, company_name, email_info, logo_url,
      agent_email,customer_support_email,customer_support_phone_number  ,
      
     } =
     companySettings;


     const {prefix, minimum_digits, use_autogenerated_number_as_ppoe_username, notify_user_account_created,
      send_reminder_sms_expiring_subscriptions, account_number_starting_value,
      use_autogenerated_number_as_ppoe_password
     }= subscriberSettings;


  const [ routerName] = useDebounce( settingsformData.router_name, 1000)

const [checkedData,  setCheckedData] = useState('')
const [open, setOpen] = useState(false);
const [openNotifactionSettings, setOpenSettings] = useState(false)
const [routers, setRouters]= useState ([])
const [mikrotik_router, setRouter] = useState(null)
console.log('checked data', checkedData)

const classes = useStyles();

// useEffect(() => {
//   if (settingsformData.router_name) {
//     setRouter(routers.find(router => router.name === settingsformData.router_name));
//   }
// }, [settingsformData.router_name, routers]);



const subdomain = window.location.hostname.split('.')[0]


const handleGetCompanySettings = useCallback(
  async() => {
    try {
      const response = await fetch('/api/get_company_settings', {
        headers: {
          'X-Subdomain': subdomain,
        },
      })
      const newData = await response.json()
      if (response.ok) {
        // setcompanySettings(newData)
        const { contact_info, company_name, email_info, logo_url,
          customer_support_phone_number,agent_email ,customer_support_email
         } = newData
         console.log(logo_url)

        setCompanySettings((prevData)=> ({...prevData, 
          contact_info, company_name, email_info,
          customer_support_phone_number,agent_email ,customer_support_email,
        
          logo_preview: logo_url
        }))

        console.log('company settings fetched', newData)
      }else{
        console.log('failed to fetch company settings')
      }
    } catch (error) {
      toast.error('internal servere error  while fetching company settings')
    
    }
  },
  [setCompanySettings],
)

useEffect(() => {
  
  handleGetCompanySettings()
  
}, [handleGetCompanySettings])
















const fetchRouters = useMemo(() => async ()=> {
  
  try {
    const response = await fetch('/api/routers',{
      headers: {
        'X-Subdomain': subdomain,
      },
  
    }
  
  
  )
  
    const newData = await response.json()
  if (response.ok) {
    console.log('router',newData)
    setRouters(newData)

  } else {
    console.log('failed to fetch routers')

  }
  
  } catch (error) {
    
    console.log(error)
  
  }
  
  
  }, [])
  



  useEffect(() => {
    
    fetchRouters()
  }, [ fetchRouters, routerName]);







useEffect(() => {
  setRouter(settingsformData.router_name)

  console.log('package_name', )
}, [ settingsformData.router_name ]);


useEffect(() => {
  const fetchRouters =  async() => {


    try {
      const response = await fetch('/api/router_settings', {
        headers: {
          'X-Subdomain': subdomain,
        },
      })
const newData = await response.json()
      if (response) {
        console.log('fetched router settings', newData)
        const {router_name, use_radius} = newData[0]
        setFormData({...settingsformData, router_name, use_radius })
        setRouter(router_name)
      } else {
        toast.error('failed to fetch router settings', {
          duration: 7000,
          position: "top-center",
        });
      }
    } catch (error) {
      toast.error('failed to fetch router settings', {
        duration: 7000,
        position: "top-center",
      });
      
    }
  }
  fetchRouters()
}, []);

       const handleUpdateSettings = async(e)=> {
        e.preventDefault()

        try {
          setisloading(true)
          setOpen(true)
          const url =  '/api/router_settings' 
         const method =   'POST' 

         const response = await fetch(url, {
          method,
          headers: {
            "Content-Type"  : 'application/json',
            'X-Subdomain': subdomain,
          },

          body: JSON.stringify(
            settingsformData
          )
         },
        
        
        )


        const newData1 = await response.json()

        if (response.ok) {
          // const {prefix, minimum_digits, check_update_username, check_update_password } = newData[0]

          
const prefix = newData1.prefix
const minimum_digits = newData1.minimum_digits
const check_update_username = newData1.check_update_username
const check_update_password  = newData1.check_update_password 
const welcome_back_message = newData1.welcome_back_message
const router_name = newData1.router_name
// setCheckedData(newData1)
          localStorage.setItem("checkedtrueData2", JSON.stringify({check_update_username,  check_update_password,
            welcome_back_message, router_name
          }))
          setFormData({...settingsformData, prefix,  minimum_digits, router_name, check_update_username,
             check_update_password,
             welcome_back_message
           })
toast.success('settings updated successfully', {
  position: "top-center",
  duration: 7000,
  
})
          setisloading(false)
          setOpen(false)
          setOpenSettings(true)
          setRouter(routers.find(router => router.name === settingsformData.router_name));

        } else {
          setOpen(false)
          toast.error('failed to update settings', {
            position: "top-center",
            duration: 7000,
            
          })
          console.log('not created')
          setisloading(false)
          setOpenSettings(false)
        }
        } catch (error) {
          toast.error(
            'Failed to update settings something went wrong',
            {
              position: "top-center",
              duration: 7000,
              
            }
          )
          console.log(error)
          setisloading(false)
          setOpenSettings(false)
        }
       }

       const handleClose = () => {
         setOpen(false);
       };
   
       
       const handleCloseNotifaction = () => {
        setOpenSettings(false);
      };

    


const handleFormDataChangeForCompany = (e) => {
  setCompanySettings((prevData)=> ({...prevData, [e.target.name]: e.target.value}))
}






const handleImageChange = (e) => {
  const file = e.target.files[0];
  if (file) {
    setCompanySettings(prevData => ({
      ...prevData,
      logo: file,
      logo_preview: URL.createObjectURL(file)
    }));
  }
};





const handleCreateCompanySettings = async (e) => {
  e.preventDefault()
try {
  setisloading(true)
  const formData = new FormData();
  formData.append('company_name', companySettings.company_name);
  formData.append('contact_info', companySettings.contact_info);
  formData.append('email_info', companySettings.email_info);
  formData.append('agent_email', companySettings.agent_email);
  formData.append('customer_support_phone_number', companySettings.customer_support_phone_number);
  formData.append('customer_support_email', companySettings.customer_support_email);




  if (companySettings.logo) {
    formData.append('logo', companySettings.logo);
  }
  const response = await fetch('/api/company_settings', {
    method: 'POST',
    headers: {
      'X-Subdomain': subdomain,
    },
   
    body: formData
  })


  const newData = await response.json()
  if (response.ok) {
    console.log('company settings created', newData)
    const { contact_info, company_name, email_info, logo_url,
      agent_email,customer_support_email,customer_support_phone_number  ,
      
     } =
     newData;


    setisloading(false)

toast.success("company settings updated successfully", {
  position: "top-center",
  duration: 7000,
})
    setCompanySettings(prevData => ({
      ...prevData, 
      contact_info, 
      company_name, 
      customer_support_phone_number,
      customer_support_email,
      agent_email,
      email_info,
      logo_preview: logo_url
    }));
  } else {
    toast.error('failed to create company settings', {
      position: "top-center",
      duration: 7000,
    })
    setisloading({...isloading, loading8: false})


    console.log('failed to create company settings')
  }

} catch (error) {
  console.log('error creating company settings',error)
  toast.error('internal server error', {
      position: "top-center",
      duration: 7000,
    })

  
  setisloading(false)
}
}




const saveSubcriberSettings = async(e) => {
  e.preventDefault()
  try {
    setisloading(true)
    setOpen(true)
    const response = await fetch('/api/subscriber_settings', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Subdomain': subdomain,
        
        
      },
      body: JSON.stringify({
       subscriber_setting: subscriberSettings
      })
    })
const newData = await response.json()
    if(response.ok){

setSubscriberSettings(
  {...subscriberSettings, prefix:newData.prefix, minimum_digits: newData.minimum_digits, 
   use_autogenerated_number_as_ppoe_username: newData.use_autogenerated_number_as_ppoe_username,
   notify_user_account_created: newData.notify_user_account_created,
   send_reminder_sms_expiring_subscriptions: newData.send_reminder_sms_expiring_subscriptions,
   account_number_starting_value: newData.account_number_starting_value,
   use_autogenerated_number_as_ppoe_password: newData.use_autogenerated_number_as_ppoe_password
  }
)

setisloading(false)
setOpen(false)
setOpenSettings(true)

toast.success('subscriber settings successfully saved', {
  position: "top-center",
  duration: 4000,
})

    }else{
      setisloading(false)
      setOpen(false)
      setOpenSettings(false)
      toast.error('failed to save subscriber settings',
        {
          position: 'top-center',
          duration: 3000,
        }
      )
    }
  } catch (error) {
    setisloading(false)
    setOpen(false)
    setOpenSettings(false)
    toast.error(
      'internal server error while saving subscriber settings',
      {
        position: 'top-center',
        duration: 3000,
      }
    )
  } 
}




const fetchSubscriberSettings = useCallback(
  async() => {
    try {
      const response = await fetch('/api/subscriber_settings',{
        headers: {
          'X-Subdomain': subdomain,
        },
      })

      const newData = await response.json()
      if (response.ok){


const {

  prefix,
  minimum_digits,
  use_autogenerated_number_as_ppoe_username,
  notify_user_account_created,
  send_reminder_sms_expiring_subscriptions,
  account_number_starting_value,
  use_autogenerated_number_as_ppoe_password
} = newData[0]



setSubscriberSettings(
  {...subscriberSettings, prefix:prefix, minimum_digits:minimum_digits, 
   use_autogenerated_number_as_ppoe_username: use_autogenerated_number_as_ppoe_username,
   notify_user_account_created: notify_user_account_created,
   send_reminder_sms_expiring_subscriptions: send_reminder_sms_expiring_subscriptions,
   account_number_starting_value: account_number_starting_value,
   use_autogenerated_number_as_ppoe_password: use_autogenerated_number_as_ppoe_password
  }
)
      }else{
toast.error('failed to fetch subscriber settings', {
  position: "top-center",
  duration: 4000,
})  
      }
    } catch (error) {
      toast.error('failed to fetch subscriber settings server error', {
        position: "top-center",
        duration: 4000,
      })  
    }
  },
  [],
)



useEffect(() => {
  fetchSubscriberSettings()
}, [fetchSubscriberSettings]);



const Button = styled(motion.button)`
margin-top: 30px;
padding: 10px 26px;
font-size: 0.9rem;
color: white;
background: black;
border: none;
border-radius: 25px;
cursor: pointer;
box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);

&:hover {
  background: green;
}
`;



const StyledAccordion = motion(Accordion);
const StyledButton = motion(Button);
const [showSuccess, setShowSuccess] = useState(false);


const SettingsCheckbox = ({ label, description, checked, onChange, name }) => (
  <div className="mb-4 p-4  rounded-lg shadow-sm">
    <FormControlLabel
      className="dark:text-white text-black mb-1"
      control={
        <Checkbox 
          checked={checked}
          onChange={onChange}
          name={name}
          color="default"
        />
      }
      label={<span className="font-medium">{label}</span>}
    />
    <p className="ml-8 text-sm text-black dark:text-white">
      {description}
    </p>
  </div>
);
  return (

    <>
     {/* {children} */}
     <Suspense fallback={<div className='flex justify-center items-center '>{ <UiLoader/> }</div>}>
    {/* <GeneralContext.Provider > */}
    <Toaster />
<Backdrop  handleClose={handleClose}  open={open}/>
<SettingsNotification open={openNotifactionSettings} handleClose={ handleCloseNotifaction }/>



<Accordion>
<AccordionSummary
          expandIcon={
            <ArrowDownwardIcon
            className='  text-black dark:text-white'
            />
          }
          aria-controls="panel1-content"
          id="panel1-header"
          sx={{
            backgroundColor: "rgba(0, 0, 0, 0.05)",
            borderRadius: "10px",
            color: "black",
          }}
        >
          <Typography variant="h6">
            
            <p className='dark:text-white text-black'>User Registration</p>
            
            </Typography>
        </AccordionSummary>
        <AccordionDetails
          sx={{
            backgroundColor: "rgba(0, 0, 0, 0.05)",
            borderRadius: "10px",
            marginTop: "10px",
            padding: "20px",
          }}
        >
<form onSubmit={handleUpdateSettings}>
  <motion.div    transition={{duration:0.5, ease: "easeInOut",
  }} initial='hidden'  id="" 
  className={`
   `}
   >
    <div className="p-5 border border-b-0 border-gray-200 ">
   

    <SettingsCheckbox
      label="Login with OTP"
      description="When enabled, administrators will receive a one-time 
      password via SMS during two-factor authentication login. This adds an extra layer of security by requiring both password and SMS verification."
      
      name="login_with_otp"
    />

    <SettingsCheckbox
      label="Login with Email OTP"
      description="When enabled, administrators will receive a one-time password via email during two-factor authentication login. This provides an alternative verification method using email instead of SMS."
     
      name="login_with_otp_email"
    />

    <SettingsCheckbox
      label="Enable Two-Factor Authentication (2FA)"
      description="Requires administrators to verify their identity using both a password and a verification code. This significantly enhances account security by adding an additional verification step."
     
      name="enable_2fa_for_admin"
    />

    <SettingsCheckbox
      label="Enable Two-Factor Authentication for Admin Passkeys"
      description="Allows administrators to use passkeys in addition to passwords for two-factor authentication. This provides an extra layer of security."
     
      name="enable_2fa_for_admin_passkeys"
    />

    <SettingsCheckbox
      label="Logout an admin after a period of inactivity"
      description="When enabled, administrators will be logged out automatically after a specified period of inactivity."
      
      name="check_is_inactive"
    />


      <Box
       className='dark:text-black myTextField'
      component="form"
      sx={{
        '& .MuiTextField-root': { m: 1, },
      }}
      noValidate
    >


{/* Admin Inactivity Settings */}
<div className="space-y-6 p-4  rounded-lg shadow-sm">
  <h3 className="text-lg font-medium text-black dark:text-white">Inactivity Timeout Settings</h3>
  
  <div className="space-y-4 ">
    <div className=' '>
      <TextField 
      

        sx={{
          width: '100%',

          '& label.Mui-focused': {
            color: 'black',
            fontSize:'16px'
          },
          '& .MuiOutlinedInput-root': {
            "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
              borderColor: "black",
              borderWidth: '3px'
            },
            '&.Mui-focused fieldset': {
              borderColor: 'black',
            }
          },
        }}
        id="inactive-hours"
        label="Logout After Inactivity (Hours)"
        type="number"
        name="check_inactive_hrs"
       
        helperText={
        <p className='dark:text-white text-black text-lg md:w-full md:text-sm  text-wrap w-[140px]'>Automatically log out administrators after
        this many hours of inactivity. Enter 0 to disable hour-based logout.</p>}


      />
    </div>

    <div>
      <TextField 
        sx={{
          width: '100%',
          '& label.Mui-focused': { color: 'black' },
          '& .MuiOutlinedInput-root': {
            "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
              borderColor: "black",
              borderWidth: '3px'
            }
          }
        }}
        id="inactive-days"
        label="Logout After Inactivity (Days)"
        type="number"
        name="check_inactive_days"
       
        helperText=
        {
          <p className='dark:text-white text-black text-lg md:w-full md:text-sm  text-wrap w-[140px]'>Automatically log out administrators after this many days of inactivity.
           Useful for long-term security. Enter 0 to disable day-based logout</p>}
      />
    </div>

    <div>
      <TextField 
        sx={{
          width: '100%',
          '& label.Mui-focused': { color: 'black' },
          '& .MuiOutlinedInput-root': {
            "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
              borderColor: "black",
              borderWidth: '3px'
            }
          }
        }}
        id="inactive-minutes"
        label="Logout After Inactivity (Minutes)"
        type="number"
        name="check_inactive_minutes"
     
        helperText={<p className='dark:text-white text-black text-lg md:w-full md:text-sm  text-wrap w-[140px]'>Automatically log out administrators after this many minutes of inactivity.
         Recommended for high-security environments. Enter 0 to disable minute-based logout</p>}
      />
    </div>
  </div>

  <div className="bg-gray-50 dark:bg-gray-700 p-4 rounded-md mt-4">
    <p className="text-sm text-black dark:text-gray-300">
      <strong className='text-black dark:text-white'>How it works:</strong> The system will log out administrators after any of these time periods are reached. 
      For example, setting 2 hours, 1 day, and 30 minutes will trigger a logout after either 2 hours, 1 day, or 30 minutes 
      of inactivity, whichever comes first.
    </p>
  </div>
</div>

{/* User Invitation Settings */}
<div className="space-y-6 p-4  rounded-lg shadow-sm mt-6">
  <h3 className="text-lg font-medium text-black dark:text-white">User Invitation Settings</h3>

  <div className="space-y-4">
    <div className="p-4  rounded-md">
      <FormControlLabel
        className="mb-2"
        control={
          <Checkbox
         
            name="send_password_via_email"
            color="default"
          />
        }
        label={
          <div>
            <p className="font-medium text-black dark:text-white">Send Invite Via Email</p>
            <p className="text-sm text-black dark:text-white mt-1">
              When enabled, new users will receive their login credentials and initial password through email. 
              This is the recommended method for business email addresses.
            </p>
          </div>
        }
      />
    </div>

    <div className="p-4 rounded-md">
      <FormControlLabel
        className="mb-2"
        control={
          <Checkbox
            
            name="send_password_via_sms"
            color="default"
          />
        }
        label={
          <div>
            <p className="font-medium text-black dark:text-white">Send Invite Via SMS</p>
            <p className="text-sm text-black dark:text-white mt-1">
              When enabled, new users will receive their login credentials and initial password through SMS. 
              This method ensures immediate delivery to mobile devices and is useful when email access is limited.
            </p>
          </div>
        }
      />
    </div>
  </div>

  <div className="bg-yellow-50 dark:bg-yellow-900 p-4 rounded-md mt-4">
    <p className="text-sm text-yellow-800 dark:text-yellow-200">
      <strong>Security Note:</strong> It's recommended to enable at least one invitation method to ensure 
      new users can securely receive their login credentials. For maximum security, consider enabling both 
      methods for critical user accounts.
    </p>
  </div>
</div>

        </Box>

      



       <Tooltip title={<p className='text-lg'>users will be invited to the system via email and they will use passkeys during authentication(login)
       </p>}>
        <FormControlLabel
        
        className='dark:text-white text-black'
         name='login_with_web_auth'  control={<Checkbox color="default"
          />  } 
        label="Invite users with email(users will be invited to the system via passkeys)" />
       </Tooltip>


<div className='p-5'>
<Button
        whileHover={{ scale: 1.1 }}
        whileTap={{ scale: 0.9 }}
      >
        update settings
      </Button>


      

        </div>
    </div>
  </motion.div>
  </form>
  </AccordionDetails>
  </Accordion>


{/* 
<form onSubmit={handleUpdateSettings}>

<Accordion  sx={{
            backgroundColor: 'transparent',
          }}>
        <AccordionSummary
          expandIcon={<ArrowDownwardIcon />}
          aria-controls="panel1-content"
          id="panel1-header"
         
        >
          <Typography>Router Management</Typography>
        </AccordionSummary>
        <AccordionDetails>

          <Typography>
          

          <Autocomplete
                      value={routers.find((router)=> router.name === settingsformData.router_name)|| null}

  sx={{
width:{
  xs: '55%'
},
    '& label.Mui-focused': {
      color: 'black',
      fontSize:'16px'
      },
    '& .MuiOutlinedInput-root': {
    "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
      borderColor: "black",
      borderWidth: '3px'
      },
    '&.Mui-focused fieldset':  {
      borderColor: 'black', 
    
    }
    },
             
            }} 

            
                  getOptionLabel={(router) => router.name}

        options={routers}
        
                renderInput={(params) => (
                  <TextField
                  id="router_name"
                  getOptionValue={(option) => option.id}   

                  className='myTextField'
                    {...params}
                    label="Select Router"
                 

                   
                  />
                  
                )}
              
                onChange={(event, newValue) => {
                  console.log("Selected Router:", newValue);

                  setFormData({...settingsformData, router_name: newValue ? newValue.name : '' });
                }}

                renderOption={(props, routerName) => (
                  <Stack
                    direction='row'
                    spacing={2}
                    sx={{
                      width: '100%',
                      padding: 1,
                      '&:hover': {
                        backgroundColor: 'rgba(0, 0, 0, 0.1)',
                        display: 'flex',
                        flexDirection: 'start'
                      }
                    }}
                    {...props}
                  >
                   <img  className='w-[60px] h-[50px]' src="/images/icons8-router-80.png" alt="router" />
                    <Stack direction='column'>
                    <span>{routerName.name}</span>
                    </Stack>
                  
                  </Stack>
                  
                )}
              />

          </Typography>


          <Button
        whileHover={{ scale: 1.1 }}
        whileTap={{ scale: 0.9 }}
      >
        update settings
      </Button>
        </AccordionDetails>
      </Accordion>

      </form> */}




<form onSubmit={handleUpdateSettings}>
      <Accordion
        sx={{
          backgroundColor: "transparent",
          boxShadow: "none",
        }}
      >
        <AccordionSummary
          expandIcon={
            <ArrowDownwardIcon
            className='dark:text-white text-black'
              sx={{  transition: "transform 0.3s" }}
            />
          }
          aria-controls="panel1-content"
          id="panel1-header"
          sx={{
            backgroundColor: "rgba(0, 0, 0, 0.05)",
            borderRadius: "10px",
            color: "black",
          }}
        >
          <Typography variant="h6">
            
            <p className='dark:text-white text-black'>Router Management</p>
            
            </Typography>
        </AccordionSummary>

        
        <AccordionDetails
          sx={{
            backgroundColor: "rgba(0, 0, 0, 0.05)",
            borderRadius: "10px",
            marginTop: "10px",
            padding: "20px",
          }}
        >
          <Typography variant="body1" sx={{ mb: 2 }}>
            <strong>What does this setting do?</strong>
            <br />
            This setting allows you to select a router that will be applied
            system-wide. Choosing the correct router ensures effective
            communication between your system and the router, optimizing network
            performance.
          </Typography>

          <Autocomplete
            value={
              routers.find((router) => router.name === settingsformData.router_name) ||
              null
            }
            sx={{
              width: { xs: "100%", sm: "55%" },
              "& label.Mui-focused": {
                color: "black",
                fontSize: "16px",
              },
              "& .MuiOutlinedInput-root": {
                "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
                  borderColor: "black",
                  borderWidth: "3px",
                },
                "&.Mui-focused fieldset": {
                  borderColor: "black",
                },
              },
            }}
            getOptionLabel={(router) => router.name}
            options={routers}
            renderInput={(params) => (
              <TextField
                id="router_name"
                className="myTextField"
                {...params}
                label="Select Router"
              />
            )}
            onChange={(event, newValue) => {
              console.log("Selected Router:", newValue);

              setFormData({...settingsformData, router_name: newValue ? newValue.name : '' });
            }}
            renderOption={(props, router) => (
              <Stack
                direction="row"
                spacing={2}
                sx={{
                  width: "100%",
                  padding: 1,
                  "&:hover": {
                    backgroundColor: "rgba(0, 0, 0, 0.1)",
                  },
                }}
                {...props}
              >
                <img
                  className="w-[60px] h-[50px]"
                  src="/images/icons8-router-80.png"
                  alt="router"
                />
                <Stack direction="column">
                  <span>{router.name}</span>
                </Stack>
              </Stack>
            )}
          />

          {showSuccess && (
            <motion.div
              initial={{ opacity: 0, y: -20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.5 }}
              style={{
                display: "flex",
                alignItems: "center",
                marginTop: "10px",
                color: "#4CAF50",
              }}
            >
              <CheckCircleIcon sx={{ mr: 1 }} />
              <Typography variant="body1">
                Router selected successfully! Settings applied system-wide.
              </Typography>
            </motion.div>
          )}

        

<Tooltip title={<p className='text-lg'>
  RADIUS authentication and accounting gives the ISP or network administrator ability to
   manage PPP user access and accounting from one server throughout a large network.
       </p>}>
        <FormControlLabel  className='dark:text-white text-black'
         name='use_radius'  control={<Checkbox color="default"
          checked={settingsformData.use_radius}
          onChange={handleChange}
          />  } 
          label={
            <div>
              <p className="font-medium text-black dark:text-white">use radius authentication</p>
              <p className="text-sm text-black dark:text-white mt-1">
              Manage pppoe 
              authentication and accounting from one server throughout a large network
              </p>
            </div>
          } />
       </Tooltip>
          <Tooltip title="Update router settings system-wide">
            <Button
              type="submit"
              sx={{
                marginTop: "20px",
                padding: "10px 20px",
                backgroundColor: "#ff6f61",
                color: "white",
                borderRadius: "25px",
                "&:hover": {
                  backgroundColor: "#ff4a3d",
                },
              }}
              whileHover={{ scale: 1.1 }}
              whileTap={{ scale: 0.9 }}
              component={motion.button}
            >
              Update Settings
            </Button>
          </Tooltip>
        </AccordionDetails>
      </Accordion>
    </form>




















      <form onSubmit={saveSubcriberSettings} className='mt-4'>
      <Accordion   sx={{
            backgroundColor: 'transparent',
          }}>
        <AccordionSummary
          expandIcon={
            <ArrowDownwardIcon
            className='dark:text-white text-black'
              sx={{  transition: "transform 0.3s" }}
            />
          }
          aria-controls="panel1-content"
          id="panel1-header"
          sx={{
            backgroundColor: "rgba(0, 0, 0, 0.05)",
            borderRadius: "10px",
            color: "black",
          }}
        >
          <Typography variant="h6">
            
            <p className='dark:text-white text-black'>Fixed Subscriber Account</p>
            
            </Typography>
        </AccordionSummary>
        <AccordionDetails
         sx={{
          backgroundColor: "rgba(0, 0, 0, 0.05)",
          borderRadius: "10px",
          marginTop: "10px",
          padding: "20px",
        }}
        >

          <Typography>

            <FormGroup>
            <div className='flex '>

          <FormControlLabel     sx={{
            width:{
              xs: '65%',
              sm: '60%',
              md: '60%',
              lg: '30%',
              xl:'30%'
            }
          }}   control={<Checkbox color="default"/>} 
          label="Only Show Packages for Current Zone/Subdomain on homepage" />
          <Tooltip  classes={{
          tooltip: classes.customTooltip,
          arrow: classes.customArrow
        }} sx={{
            width: '20%',
            background: 'red'
          }}  title={<p className='text-lg font-extrabold'>Zone as subdomain <span className='font-extralight  text-sm font-mono'>
Show only the subscription packages to a particular area/zone. Feature is only available for isps who
 have custom domains setup for the portal. Contact us at +254791568852 for setup
            </span></p>} enterDelay={500} leaveDelay={200}>
 
          <Stack sx={{ width: 0 , display: 'flex', justifyContent: 'center'}} spacing={2}>
      <Alert sx={{background: 'transparent'}}  severity="info"></Alert>
     
    </Stack>
    </Tooltip>
    </div>
 

    <FormControlLabel      sx={{
            width:{
              xs: '65%',
              sm: '60%',
            },
            marginTop: 2
            
          }}  control={<Checkbox color="default"/>} label="Notify Customer After Sucesful Subscription Renewal" />

<div className='flex'>
    <FormControlLabel sx={{
       width:{
        xs: '25%',
        sm: '30%',
        marginTop: 30
      }
    }}  control={<Checkbox  color="default" />} label="Email Receipt To Customer On Sucessful Subscription Renewal" />

    <Tooltip title={<p className='text-lg font-extrabold'>Email Setup Required
         <span className='font-extralight  text-sm font-mono'>  Email must be set up in the EMAIL settings tab for receipts 
to be automatically emailed</span></p>} enterDelay={500} leaveDelay={200}>
 
          <Stack sx={{ width: 0 , display: 'flex', justifyContent: 'center'}} spacing={2}>
      <Alert sx={{background: 'transparent'}} severity="info"></Alert>
     
    </Stack>
    </Tooltip>
    </div>
    <FormControlLabel sx={{
       width:{
        xs: '25%',
        sm: '30%',
        marginTop: 20
        
      }
    }}  control={<Checkbox color="default" />} label="Automatically Send Reminder SMS for Expiring Subscriptions"  />
    <Box
              className='myTextField'

      component="form"
      sx={{
        '& .MuiTextField-root': { m: 1, width: {
          sm: '50ch',
          xs: '25ch',
          md:'60ch',
          lg: '100ch',
          xl: '130ch'
        }, 
       },

  '& label.Mui-focused': {
    color: 'black'
    },

'& .MuiOutlinedInput-root': {
  
  "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
    borderColor: "black",
    borderWidth: '3px'
    },
 '&.Mui-focused fieldset':  {
    borderColor: 'black', // Set border color to transparent when focused

  }
},
      }}
      noValidate
    >
  <TextField
          
          label="Reminder Intervals"
          helperText="Enter Days to/after expiry when reminders should be sent separated by
           commas e.g 5,2,1,0,+2,+4 to send reminders at 5,2, or 1 day to expiry, on the day of expiry and 
           for subscriptions that expired 2 or 4 days ago.

          "
        />

        </Box>


        <FormControlLabel  control={<Checkbox color="default"/>} label="Send Reminder On the Same Date Every Month"  />
        <FormControlLabel  control={<Checkbox color="default"/>} label="Set Expiry date of 30 day fixed/home
         subscriptions to same date (leave unchecked to only add 30 days to subscription)"  />
 <FormControlLabel  control={<Checkbox  color="default"/>} label="Create Partial Subscription for Partial
  Payments (Extend subscription by number of days corressponding to amount paid if partial payment)"  />
<FormControlLabel  control={<Checkbox color="default"
checked={use_autogenerated_number_as_ppoe_username}
onChange={handleChangeSubscriberSettings}
name='use_autogenerated_number_as_ppoe_username'
/>} label="Use Auto Generated Account Number As PPOE username"  />


<FormControlLabel  control={<Checkbox  color="default"/>} label="Notify User Once Their Account Is Created"  />
<FormControlLabel  control={<Checkbox color="default" />} label="Use Node Code As Account Prefix"  />

</FormGroup>

        <Stack direction='row'   sx={{
        '& .MuiTextField-root': { m: 1, width: '90ch',    '& label.Mui-focused': {
          color: 'black',
          fontSize: '16px'
          },
      '& .MuiOutlinedInput-root': {
        "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
          borderColor: "black",
          borderWidth: '3px',
          },
       '&.Mui-focused fieldset':  {
          borderColor: 'black', 
          
        }
      } },
      }}   spacing={{
          xs: 1,
          sm: 2
        }}>

          <TextField  name='prefix' className='myTextField' onChange={handleChangeSubscriberSettings} value={prefix}
          label='Subscriber Account No Prefix' ></TextField>
          <TextField name='minimum_digits'  className='myTextField'   onChange={handleChangeSubscriberSettings}
           value={minimum_digits} 
             type='number'  label='Subscriber Account No Minimum Digits(Zeros will be added to the front, eg SUB001 for three digits)'></TextField>

        </Stack>



          <div className='border-2  dark:border-black  shadow-xl lg:h-[280px]  sm:h-[400px]   max-md:h-[500px]  max-sm:h-[600px] ,
           flex justify-center items-center flex-col gap-y-2 p-1'>
          <Stack  sx={{
            width: {
              sm: '40ch',
              lg: '110ch',
              xl: '150ch'
            },

           marginBottom:  {
sm: '120px',
lg: '55px',
xs: '30ch'
            },

            height: {
              sm: '10ch',
              xs: '1ch'
            }
          }}>
    
      <Alert severity="info">
        <AlertTitle>Set Account No. Counter Starting Value</AlertTitle>
        Use this to set the value from which the account number counter should start from. Run once after importing a list of customers to make sure account numbers continue from the uploaded values. Set the values of the highest account number.
.
      </Alert>
     
    </Stack>

<Box  sx={{
        '& .MuiTextField-root': { m: 1, width: {sm: '35ch', lg: '95ch', xl: '130ch' },   '& label.Mui-focused': {
          color: 'black',
          fontSize: '16px'
          },
      '& .MuiOutlinedInput-root': {
        "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
          borderColor: "black",
          borderWidth: '3px',
          },
       '&.Mui-focused fieldset':  {
          borderColor: 'black', 
          
        }
      } },
      }}>
<TextField    label='Current Account(exclude prefix)'     className='myTextField'></TextField>

</Box>

          </div>


        <FormGroup sx={{
        }}>
     
      <FormControlLabel  control={<Checkbox  color="default" checked={use_autogenerated_number_as_ppoe_password} 
       onChange={handleChangeSubscriberSettings}  name='use_autogenerated_number_as_ppoe_password'/>} 
         label="Use Auto-Generated Customer PPPoE Password" />
      <FormControlLabel control={<Checkbox color="default"/>}  color="default" label="Lock PPPoE account to the MAC Address detected on 
      first dial (The first MAC Address detected will be saved as the accounts Sticky MAC address and must
         be deleted to switch to a new device)"
 />
      <FormControlLabel control={<Checkbox  color="default"/>} label="Allow Subscriber accounts to have more than one client device" />
      <FormControlLabel control={<Checkbox  color="default"/>} label="Use the same Username/Password for
       all devices in a multidevice account" />
      <FormControlLabel control={<Checkbox  color="default"/>} label="Automatically Redeem points when redeemable amount is reached" />

    </FormGroup>


          <Stack direction='row'>

            {/* <Button  className='mt-7'type='submit'  loading={isloading} startIcon={<AutorenewIcon/>}
              >Update General Settings</Button> */}


<Button
type='submit'
        whileHover={{ scale: 1.1 }}
        whileTap={{ scale: 0.9 }}
      >
        update settings
      </Button>
          </Stack>

          </Typography>
        </AccordionDetails>
      </Accordion>
      </form>






      <form onSubmit={handleCreateCompanySettings}>

<Accordion  sx={{
            backgroundColor: 'transparent',
          }}>
      <AccordionSummary
       className='bg-slate-200 dark:bg-slate-900 rounded-2xl shadow-sm'
          expandIcon={
            <ArrowDownwardIcon
            className='dark:text-white text-black
            '
              sx={{  transition: "transform 0.3s" }}
            />
          }
          aria-controls="panel1-content"
          id="panel1-header"
          sx={{
            borderRadius: "10px",
            color: "black",
          }}
         
        >
          <Typography variant="h6">
            
            <p className='dark:text-white text-black'>Company Settings</p>
            
            </Typography>
            
        </AccordionSummary>
        <AccordionDetails
        className='bg-slate-200 dark:bg-slate-900 p-4 rounded-lg shadow-sm'
         sx={{
          // backgroundColor: "rgba(0, 0, 0, 0.05)",
          borderRadius: "10px",
          marginTop: "10px",
          padding: "20px",
        }}
        >

          <Typography>
          
          <Stack direction='column' className='myTextField' sx={{
          '& .MuiTextField-root': { 
            m: 1, 
            marginTop: '30px',  
            '& label.Mui-focused': {
              color: 'black',
              fontSize: '16px'
            },
            '& .MuiOutlinedInput-root': {
              "&.Mui-focused .MuiOutlinedInput-notchedOutline": {
                borderColor: "black",
                borderWidth: '3px'
              },
              '&.Mui-focused fieldset': {
                borderColor: 'black',
              }
            } 
          },
        }} spacing={{xs: 1, sm: 2}}>

          {/* Existing text fields */}
          <TextField  
            name='company_name'
            value={company_name}
            onChange={handleFormDataChangeForCompany}
            label='Company Name' 
            type='text'
          />

          <TextField  
            onChange={handleFormDataChangeForCompany}
            name='email_info'
            value={email_info}
            label='Email Info' 
            type='text'
          />

          <TextField  
            onChange={handleFormDataChangeForCompany}
            name='contact_info'
            value={contact_info}
            label='Company Contact Info' 
            type='text'
          />


<TextField  
            onChange={handleFormDataChangeForCompany}
            name='agent_email'
            value={agent_email}
            label='Agent Email' 
            type='text'
          />


<TextField  
            onChange={handleFormDataChangeForCompany}
            name='customer_support_phone_number'
            value={customer_support_phone_number} 
            label='Customer Support Phone Number'
            type='text'
          />




<TextField  
            onChange={handleFormDataChangeForCompany}
            name='customer_support_email'
            value={customer_support_email} 
            label='Customer Support Email'  
            type='text'
          />

          {/* Add the new image upload section */}
          <div className="flex flex-col gap-4 p-4">
            <label className="text-lg font-medium  dark:text-white text-black">Company Logo</label>
            <input
              type="file"
              accept="image/*"
              onChange={handleImageChange}
              className="hidden"
              id="logo-upload"
            />
            
            <label 
              htmlFor="logo-upload"
              className="flex items-center justify-center p-4 border-2
               border-dashed border-gray-300 rounded-lg cursor-pointer
                hover:border-gray-400"
            >
              {companySettings.logo_preview ? (
                <div className="relative">
                  <img 
                    src={companySettings.logo_preview}
                    alt="Logo preview" 
                    className="max-w-xs max-h-48 object-contain"
                  />
                  <button
                    onClick={(e) => {
                      e.preventDefault();
                      setCompanySettings(prev => ({...prev, logo: null, logo_preview: null}));
                    }}
                    className="absolute top-0 right-0 bg-red-500 text-white p-1 rounded-full"
                  >
                    ×
                  </button>
                </div>
              ) : (
                <div className="text-gray-500">
                  <p className='dark:text-white text-black'>Click to upload company logo</p>
                  <p className="text-sm dark:text-white text-black">PNG, JPG up to 5MB</p>
                </div>
              )}
            </label>
          </div>

        </Stack>

         

          </Typography>


          {/* <Button className='mt-7'  type='submit'>Update General Settings</Button> */}
          <Button
          type='submit'
        whileHover={{ scale: 1.1 }}
        whileTap={{ scale: 0.9 }}
      >
        update settings
      </Button>
        </AccordionDetails>
      </Accordion>

      </form>


      {/* </GeneralContext.Provider > */}
      </Suspense >
     
      </>
   
  )
}

export default GeneralSettings
// export const useSettings = (()=> useContext(GeneralContext ))

